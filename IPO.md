# 《超市 AI 营销系统》

**IPO · 开发流程说明（第三次输出）**

---

## 一、阶段总览

本开发流程按照 **P0 ~ P9** 十个阶段划分，所有阶段均以 **Input → Process → Output** 形式描述，保证任意本科生照着步骤即可完成系统的实现与演示。

| 阶段编号 | 阶段名称     | 目标说明                      |
| ---- | -------- | ------------------------- |
| P0   | 需求理解     | 吃透作业要求与数据特点，形成可实现的功能列表    |
| P1   | 后端初始化    | 完成 Python 项目骨架与基础环境搭建     |
| P2   | 数据库设计    | 设计逻辑数据模型，编写数据导入与清洗脚本      |
| P3   | 公共模块开发   | 实现数据加载、配置、日志、可视化等公共组件     |
| P4   | 核心业务模块开发 | 实现推荐、促销分析、销售预测、客户聚类等核心算法  |
| P5   | 前端初始化    | 选择并搭建命令行或 Tkinter 简易界面框架  |
| P6   | 用户端开发    | 完成“客户视角”相关操作入口（查看推荐等）     |
| P7   | 管理端开发    | 完成“管理视角”相关操作入口（促销、预测、聚类等） |
| P8   | 联调与测试    | 将界面与各业务模块打通，完成功能与演示流程测试   |
| P9   | 打包与部署    | 整理运行脚本与依赖，使系统可在答辩环境稳定运行   |

> 说明：P4 阶段名称沿用模板中的“核心业务模块”，本项目的业务对象为 **营销分析模块**，不涉及真实下单、购物车等交易流程。

---

## 二、各阶段 IPO 详细说明

### P0 阶段：需求理解

**1. Input**

* 作业说明文档（项目需求、开发要求、作业要求）
* 提供的《商城详细销售数据》CSV 数据集
* 指导教师口头说明、课堂补充要求

**2. Process**

1. 逐条拆解作业需求，明确对应系统功能：

   * 客户个性化推荐
   * 商品促销活动分析
   * 销售额和利润预测
   * 客户聚类分析与营销策略
   * 语音播报展示结果
2. 区分功能优先级：Must / Should / Could。
3. 对 CSV 数据进行初步浏览：

   * 了解每个字段含义（订单 ID、客户 ID、产品 ID、销售额、利润等）；
   * 粗略统计行数、时间跨度。
4. 确定技术路线：

   * 使用 Python + pandas + scikit-learn + matplotlib + 本地 TTS；
   * 单机运行，不做网络服务。
5. 形成初步模块划分与数据表设计草图。

**3. Output**

* 《需求理解与功能映射说明》（简要文档或 README）
* 功能清单与优先级表
* 数据字段说明与初步逻辑表草图
* 后续开发阶段的任务拆分列表

---

### P1 阶段：后端初始化

**1. Input**

* P0 输出的功能与模块规划
* 既定技术选型方案

**2. Process**

1. 在本地创建项目目录结构示例：

```text
supermarket_ai/
├─ data/                # 原始与中间数据
├─ docs/                # 需求、设计文档
├─ src/
│   ├─ __init__.py
│   ├─ config.py
│   ├─ main.py
│   ├─ data_loader.py
│   ├─ utils/
│   └─ modules/
└─ requirements.txt
```

2. 创建并激活 Python 虚拟环境（如 `venv`）。
3. 在 `requirements.txt` 中写入核心依赖：

   * pandas、numpy、scikit-learn、matplotlib、pyttsx3 等。
4. 编写 `config.py`：

   * 数据文件路径常量；
   * 图表输出目录；
   * 默认参数（聚类数量、预测周期等）。
5. 在 `main.py` 中写入最小可运行入口（打印“系统启动成功”）。

**3. Output**

* 可激活的虚拟环境和已安装依赖
* 结构清晰的项目目录
* 可运行的 `main.py` 骨架程序
* `requirements.txt` 初稿

---

### P2 阶段：数据库设计与数据准备

**1. Input**

* P0 中的数据字段说明与逻辑表设计草图
* 原始 CSV 文件
* P1 中项目骨架与配置文件

**2. Process**

1. 完善逻辑数据模型：

   * 确认 `dim_customer`、`dim_product`、`fact_order`、`fact_order_item` 等逻辑表结构；
   * 设计派生表 `dm_customer_rfm`、`dm_sales_summary`。
2. 选择实现方式：

   * 方案 A：仅使用 pandas DataFrame，在内存中模拟上述数据表结构；
   * 方案 B（选做）：使用 SQLite 建立物理表，并在 Python 中使用 `sqlite3` 读写。
3. 编写 `data_loader.py`：

   * 读取原始 CSV；
   * 进行类型转换（日期转 datetime，销售额/利润转 float 等）；
   * 处理缺失值、异常值；
   * 根据逻辑模型构造 DataFrame 或写入 SQLite。
4. 编写简单测试脚本或单元测试：

   * 检查数据行数是否合理；
   * 随机抽取几行检查字段解析是否正确。

**3. Output**

* 完整的数据模型设计说明（可作为文档或注释）
* `data_loader.py` 模块及其测试脚本
* 已经成功加载并清洗的样例数据（可缓存为中间文件）

---

### P3 阶段：公共模块开发

**1. Input**

* P1 后端骨架与目录结构
* P2 中的数据加载与清洗模块

**2. Process**

1. 在 `src/utils/` 下实现通用工具模块：

   * `logger_util.py`：封装日志输出格式（时间、级别、模块名）；
   * `plot_util.py`：封装折线图、柱状图、饼图的绘制函数；
   * `metrics_util.py`：封装常用统计指标（平均值、标准差等）。
2. 编写 `tts_util.py`（或放在 `modules/tts.py`）：

   * 使用 `pyttsx3` 初始化语音引擎；
   * 实现 `speak(text: str)` 函数；
   * 提供基础参数设置（语速、音量）。
3. 在 `config.py` 中集中管理路径、默认参数；
4. 对公共函数编写简单示例调用，确保可用。

**3. Output**

* `utils` 工具模块集合
* 可直接调用的 `speak()` 函数
* 若干通用绘图函数和统计函数
* 更新后的项目结构与文档说明

---

### P4 阶段：核心业务模块开发

> 本阶段为本项目的“核心业务模块”，包括：客户推荐、促销分析、销售预测、客户聚类。

**1. Input**

* 已清洗的数据对象（DataFrame 或 SQLite 表）
* 公共工具模块与配置文件

**2. Process**

在 `src/modules/` 目录下分别实现各业务模块：

1. `recommender.py`（客户推荐模块）

   * 提供函数 `build_customer_baskets()`：

     * 按订单 ID 聚合订单明细，得到每个订单的商品集合；
     * 再按客户 ID 合并订单，得到客户购物清单。
   * 提供函数 `recommend_for_customer(customer_id, top_n)`：

     * 统计客户各类商品的购买频次与金额；
     * 结合全局畅销榜，生成 Top N 推荐商品；
     * 返回包含商品 ID、名称、推荐理由的列表。

2. `promotion.py`（商品促销分析模块）

   * 提供函数 `calc_product_metrics()`：

     * 对每个商品统计销量、销售额、利润、利润率、折扣等；
   * 提供函数 `select_promotion_candidates(rules)`：

     * 根据规则选择促销商品，如“销量低且利润率高”等；
     * 输出促销清单。

3. `forecast.py`（销售预测模块）

   * 提供函数 `build_sales_timeseries(freq='M')`：

     * 按日/按月聚合销售额与利润；
   * 提供函数 `train_and_predict_sales(horizon)`：

     * 使用简单线性回归或多项式回归；
     * 输出未来若干时间点的预测值；
     * 返回历史与预测结果，以便绘图与播报。

4. `clustering.py`（客户聚类模块）

   * 提供函数 `calc_rfm()`：

     * 计算每个客户的 Recency、Frequency、Monetary；
   * 提供函数 `kmeans_cluster(k)`：

     * 对标准化后的 RFM 指标进行 KMeans 聚类；
     * 返回每个客户的聚类标签及聚类中心。
   * 提供函数 `explain_clusters()`：

     * 计算各群体的平均 R/F/M；
     * 生成文本化分群解释（高价值、潜力、沉睡等）。

5. 为上述模块编写独立测试脚本或 `if __name__ == '__main__':` 形式的小样例，验证每个模块能单独运行。

**3. Output**

* `recommender.py`、`promotion.py`、`forecast.py`、`clustering.py` 等核心业务代码
* 每个模块对应的样例测试脚本
* 可在 Python 控制台中直接调用并得到结果的核心函数

---

### P5 阶段：前端初始化

> 前端此处指“人机交互层”，可以是命令行界面，也可以是 Tkinter 简单窗体界面。为保证工作量可控，可先完成命令行版本。

**1. Input**

* 可用的核心业务模块
* 项目对交互方式的要求（命令行或 GUI）

**2. Process**

1. 设计基础交互结构：

   * 主菜单：

     1. 客户推荐
     2. 商品促销分析
     3. 销售预测
     4. 客户聚类
     5. 语音播报
     6. 退出
2. 在 `main.py` 中实现主菜单循环：

   * 使用 `while True` 与数字选项控制功能跳转；
   * 捕获用户输入异常，给出提示并重试。
3. 若采用 Tkinter：

   * 搭建主窗口与菜单按钮；
   * 为各业务模块预留按钮点击回调函数。
4. 为每个菜单入口预留调用核心函数的位置，暂时可输出占位文本。

**3. Output**

* 基本可运行的前端框架（命令行或 GUI）
* 能够从主界面进入各模块入口的程序结构
* 统一的程序启动方式（如 `python main.py`）

---

### P6 阶段：用户端开发（“客户视角”功能）

> 用户端主要面向“客户/用户”的操作，例如查询个体客户的推荐结果。实际演示中由学生在菜单中模拟客户视角。

**1. Input**

* P5 中的前端框架
* `recommender.py` 等核心业务模块

**2. Process**

1. 在主菜单中实现「客户推荐」子流程：

   * 提示输入客户 ID 和推荐数量 N；
   * 调用 `build_customer_baskets()`（可在程序启动时预先构建）；
   * 调用 `recommend_for_customer()` 获取推荐列表；
   * 在界面上以表格形式展示推荐结果。
2. 增加语音播报入口：

   * 在客户推荐结果展示后，提供是否播报的选项；
   * 使用 `tts_util.speak()` 播放摘要文本。
3. 处理异常情况：

   * 客户 ID 不存在时给出友好提示；
   * 推荐结果为空时，说明原因（数据量太少等）。

**3. Output**

* 可完整运行的“客户推荐”流程
* 支持输入客户 ID 并查看推荐商品
* 可选的语音播报功能

---

### P7 阶段：管理端开发（“管理视角”功能）

> 管理端主要面向“超市管理人员”的操作，包括促销分析、销售预测、客户聚类等功能。

**1. Input**

* P5 前端框架
* P4 中的 `promotion.py`、`forecast.py`、`clustering.py` 模块
* 公共工具模块（绘图、语音）

**2. Process**

1. **商品促销分析界面**

   * 在主菜单中实现「商品促销分析」选项；
   * 提示输入或采用默认规则参数（销量上下限、利润率阈值等）；
   * 调用 `calc_product_metrics()` 和 `select_promotion_candidates()`；
   * 将促销候选清单按表格形式打印或在 GUI 中展示；
   * 可选：提供导出 CSV 功能。

2. **销售预测界面**

   * 在主菜单中实现「销售预测」选项；
   * 提示设置预测周期（默认 3 个月）；
   * 调用 `build_sales_timeseries()` 与 `train_and_predict_sales()`；
   * 使用 `plot_util` 绘制历史与预测折线图；
   * 展示关键预测数值，并可选择语音播报摘要结论。

3. **客户聚类分析界面**

   * 在主菜单中实现「客户聚类分析」选项；
   * 提示设置聚类数 K（默认 4）；
   * 调用 `calc_rfm()` 与 `kmeans_cluster()`；
   * 展示每个聚类的客户数量、平均 R/F/M 等；
   * 调用 `explain_clusters()` 输出分群解释文本；
   * 可选：支持查看某一类的部分客户样例。

4. 在管理端统一封装语音播报操作：

   * 在每个子模块的结果展示末尾询问是否播报；
   * 生成简短中文概要文本，传入 `speak()` 函数。

**3. Output**

* 包含促销分析、销售预测、客户聚类的完整管理端功能
* 能在统一菜单中完成分析、查看和可选语音播报
* 可直接用于课堂与答辩演示的操作路径

---

### P8 阶段：联调与测试

**1. Input**

* 已完成的用户端与管理端功能
* 清洗后的完整数据集
* 指导老师给出的测试关注点

**2. Process**

1. **功能联调**

   * 从程序启动到退出完整跑通以下场景：

     * 客户推荐 → 语音播报；
     * 促销分析 → 结果查看 → 导出（如有）；
     * 销售预测 → 图表展示 → 播报；
     * 客户聚类 → 分群解释。
   * 检查数据是否重复加载、是否存在未捕获异常。
2. **健壮性测试**

   * 使用错误输入（不存在的客户 ID、非法字符、负数参数等），验证提示是否清晰；
   * 检查在数据文件缺失时，系统能否给出错误提示而不是直接崩溃。
3. **性能与体验**

   * 记录各功能模块的运行时间，确保在样例数据规模下响应时间在可接受范围内（几秒内）；
   * 调整必要的预计算步骤（如启动时预先加载与构建部分中间结果）。
4. **演示脚本编写**

   * 整理一套 10 分钟左右的演示路径与说明用语；
   * 明确在每一步演示时要展示的界面、图表与语音。

**3. Output**

* 测试记录（可为简单表格或文档）
* 已修复的错误与更新后的代码
* 一份完整的“课堂/答辩演示脚本”

---

### P9 阶段：打包与部署

> 部署目标仅为“在导师或答辩教室的电脑上顺利跑起来”，不涉及正式上线。

**1. Input**

* 功能稳定的完整项目代码
* 测试通过的运行环境与依赖列表
* 学校答辩环境的基本信息（操作系统版本等）

**2. Process**

1. **整理运行方式**

   * 在项目根目录编写 `run.bat` 或简要说明文档；
   * 统一使用 `python main.py` 作为启动入口。
2. **依赖打包**

   * 确认 `requirements.txt` 中列出所有第三方库；
   * 可选：使用 `pip freeze > requirements.txt` 生成；
   * 在文档中说明如何在新电脑上创建虚拟环境并安装依赖。
3. **可执行文件（选做）**

   * 若需要进一步简化运行，可使用 `PyInstaller` 将项目打包为单个可执行文件；
   * 测试打包后的程序是否能在目标环境正常运行。
4. **最终检查**

   * 在与答辩环境相似的电脑上完整跑一次演示流程；
   * 修正文档中可能的路径错误与环境说明不足。

**3. Output**

* 可在目标电脑上直接运行的项目目录或打包文件
* 完整的《运行说明书》（含环境准备、启动方式、常见问题）
* 用于提交的最终代码压缩包与说明文档
